% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/analysisfunctions.R
\name{nof1.data}
\alias{nof1.data}
\title{nof1.data}
\usage{
nof1.data(
  Y,
  Treat,
  response = "normal",
  corr.y = F,
  bs.trend = F,
  y.time = NULL,
  knots.bt.block = NULL,
  block.no = NULL,
  bs.df = NULL,
  beta.prior = list("dnorm", 0, 1e-06),
  hy.prior = list("dgamma", 0.001, 0.001),
  rho.prior = list("dunif", -1, 1),
  eta.prior = list("dnorm", 0, 1e-06),
  inits = NULL,
  n.chains = 3,
  max.run = 1e+05,
  setsize = 10000,
  n.run = 50000,
  conv.limit = 1.05
)
}
\arguments{
\item{Y}{Outcome of the study. This should be a vector with \code{NA}'s
included in time order.}

\item{Treat}{Treatment indicator vector with same length as the outcome.
Can be character or numeric.}

\item{response}{Type of outcome. Right now, it can only be "normal" for a
continuous outcome}

\item{corr.y}{Indicator for whether the correlation among measurements
should be modeled. The default is \code{F}.}

\item{bs.trend}{Indicator for whether the model should adjust for trend
using splines. The default is \code{F}.}

\item{y.time}{Parameter used for modeling splines (time when the outcome
is measured). This should be a numeric vector with the same length as
the outcome.}

\item{knots.bt.block}{Parameter used for modeling splines. Indicator for
whether or not knots should be set at the end of each block (except for the
last block). If \code{TRUE}, user should then specify \code{block.no};
if \code{FALSE}, user should then specify \code{bs.df}.}

\item{block.no}{Block numbers used for modeling splines for the setting where
the knots are set at the end of each block. This should be a vector of block
numbers with the same length as the outcome.}

\item{bs.df}{Degrees of freedom for modeling splines when knots are not set
at the end of each block.}

\item{beta.prior}{Prior for the treatment-specific intercept. It should be a
list, where the first element is the distribution and the next two are the
parameters associated with the distribution. For example,
list("dnorm", 0, 1e-6) gives a normal prior with mean 0 and standard
deviation 1e-6. If truncation is desired, the last two parameters should be
the upper and lower limits for the truncation.}

\item{hy.prior}{Prior for the heterogeneity parameter. Supports uniform,
gamma, and half normal. It should also be a list of length 3, where first
element is the distribution (one of dunif, dgamma, or dhnorm) and the next
two are the parameters associated with the distribution.}

\item{rho.prior}{Prior for the correlated error model. It should be also be
a list of length 3, where the first element is the distribution and the next
two are the parameters associated with the distribution.}

\item{eta.prior}{Prior for modelling spline terms. It should also be a list
of length 3, where first element is the distribution and the next two are
the parameters associated with the distribution.}

\item{inits}{Initial values for the parameters being sampled. If left
unspecified, the program will generate reasonable initial values.}

\item{n.chains}{Number of chains to run}

\item{max.run}{Maximum number of iterations that the user is willing to run.
If the algorithm is not converging, it will run up to \code{max.run}
iterations before printing a message that it did not converge}

\item{setsize}{Number of iterations that are run between convergence checks.
If the algorithm converges quickly, a large \code{setsize} is not needed. The
number that is printed between each convergence check is the gelman-rubin
diagnostic, and the function checks whether this number is below the
user-specified convergence limit (\code{conv.limit}).}

\item{n.run}{Final number of independent iterations (i.e. minimum
effective sample size) that the user wants to store. If the user wants to
store fewer iterations after the algorithm has converged, the sequence will
be thinned. If the user wants to store more iterations, extra iterations will
be run to reach the specified number of runs.}

\item{conv.limit}{Convergence limit for Gelman and Rubin's convergence
diagnostic.}
}
\value{
An object of class "nof1.data" that is a list containing the
following:
\item{nobs}{Total number of observations in the study}
\item{Treat.name}{Treatment names}
\item{n.Treat}{Number of treatments}
\item{response}{Type of outcome}
\item{corr.y}{Indicator for whether the correlation among measurements
will be modeled}
\item{bs.trend}{Indicator for whether the model will adjust for trend
using splines}
\item{priors}{Priors that the code will be using. Default priors are used if
priors were not specified}
\item{bs_df} {The b-spline basis matrix from the bs function in the splines
package}
\item{code}{Rjags model file code that is generated using information
provided by the user with \code{nof1.normal.rjags}. To view model file
inside R, use \code{cat(nof1$code).}}
\item{pars.save}{Parameters that will be saved}
\item{data}{A list containing Y (the outcome), vectors of 0s and 1s in
the model matrix for each \emph{Treat.name}, indicating whether or not the
response was recorded under the treatment, and base spline information}
\item{n.chains}{Number of chains to run}
\item{max.run}{Maximum number of iterations that the user is willing to run}
\item{setsize}{Number of iterations that are run between convergence checks}
\item{n.run}{Final number of independent iterations (i.e. minimum
effective sample size) that the user wants to store}
\item{conv.limit}{Convergence limit for Gelman and Rubin's convergence
diagnostic}
\item{inits}{Initial values for the parameters being sampled}
}
\description{
Creates an N of 1 object containing the specified data, priors,
sample specifications, and jags model code to be passed to \code{jags.fit}
for individual analysis
}
